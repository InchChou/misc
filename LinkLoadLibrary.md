### 程序Load过程

windows目标文件是COFF格式，链接后的可执行文件是PE格式
PE文件是COFF文件的扩展

创建一个进程，主要是三件事情：
1. 创建一个独立的虚拟地址空间（实质上只是分配一个页目录(Page Directory)就可以）
2. 读取可执行文件头，并建立虚拟空间与可执行文件的映射关系
3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行
上面的步骤执行完后，其实可执行文件的真正指令和数据都没有被装入内存中，操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚拟内存之间的映射关系。
通过页错误，操作系统将所需页换入内存，然后控制权还给进程，从刚才页错误的位置重新开始执行。

### Segment（段定义）

ELF可执行文件中有一个概念叫Segment，一个Segment包含一个或多个属性类似的Section。在装载的时候可以按Segment将Section(s)一起映射。这样做的好处是可以很明显的减少页面内部碎片，从而节省了内存空间。
ELF可执行文件中有个专门的数据结构叫做程序头表（Program Header Table）用来保存Segment信息。因为ELF目标文件不需要被装载，所以它没有程序头表。ELF的可执行文件和共享库文件都有。

VMA(Virtual Memory Area)
操作系统通过给进程空间划分一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA。
一个进程基本上可以分为如下几种VMA区域：
- 代码VMA，只读、可执行；有映像文件
- 数据VMA，可读写、可执行；有映像文件
- 堆VMA，可读写、可执行；无映像文件，匿名，可向上扩展
- 栈VMA，可读写、不可执行；无映像文件，匿名，可向下扩展

### DLL导入符号的调用

MSVC产生DLL文件时，伴随着会产生一个LIB文件，即导入库。
编译器在产生导入库时，同一个导出函数会产生两个符号的定义，比如`foo`，他在导入库中有两个符号，一个是`foo`,另外一个是`__imp__foo`。这两个符号的区别是，`foo`这个符号指向`foo`函数的桩代码，而`__imp__foo`指向`foo`函数在IAT中的位置。当我们通过`__declspec(dllimport)`来声明`foo`导入函数时，编译器会在该导入函数前加上前缀`__imp__`，以确保跟导入库中的`__imp__foo`能够正确链接；如果不使用`__declspec(dllimport)`，那么编译器将会产生一个正常的foo符号调用，以便于跟导入库中的`foo`符号定义相链接。



### 重定位基地址

共享对象装载时可能会有地址冲突问题：

ELF解决办法是产生代码段地址无关代码，即PIC

PE采用的是**装载时重定位**的方法。DLL代码段不是地址无关的，装载时需要对每个绝对地址引用都进行重定位。

DLL的内部地址都是基于基地址的（DLL的基地址为一个固定值），或者是相对于基地址的RVA。那么只需要在所有需要重定位的地方加上一个固定差值。这种特殊的重定位过程在PE中叫做**重定基地址（Rebasing）**。



## 入口函数和程序初始化

**glibc：**

glibc的入口为`_start`。`_start`由汇编实现，并且和平台相关。

`_start`调用`main`的顺序为：

`_start -> __libc_start_main -> exit`

在`__libc_start_main`中调用了`main`

**MSVC CRT：**

MSVC的CRT默认入口函数为`mainCRTStartup`。

首先给一些全局变量赋值，然后初始化堆，然后执行以下操作：

- `_setargv`：初始化`main`函数的`argv`参数。

- `_setenv`：设置环境变量。

- `_cinit`：其他的C库设置。

  最后调用了`main`函数并获得了其返回值。

### 运行库与I/O

Linux和Windows都有将各种输入和输出概念泛化成“文件”的概念。

在Linux中，叫做**文件描述符（File Descriptor）**，在windows中，叫做**句柄（Handle）**。

MSVC的I/O初始化主要进行了如下几个工作：

- 建立打开文件表。
- 如果能够继承自父进程，那么从父进程获取继承的句柄。
- 初始化标准输入输出。

## C/C++运行库

任何一个C程序背后都有一套庞大的代码来进行支撑，以使得程序能够正常运行。这套代码至少包括入口函数，及所以来的函数构成的函数集合，当然它还应该包括各种标准库的实现。

这样的一个代码集合称之为**运行时库（Runtime Library）**。而C语言的运行库被称为**C运行库（CRT）**。

一个C语言运行库大致包含了如下功能：

- 启动与退出：包括入口函数及入口函数所依赖的其他函数等。
- 标准函数：由C语言标准规定的C语言标准库所拥有的函数实现。
- I/O：I/O功能的封装和实现。
- 堆：堆的封装和实现。
- 语言实现：语言中一些特殊功能的实现。
- 调试：实现调试功能的代码。



## `fread`实现

在windows系统中，`fread`最终调用到系统API:`ReadFile()`。

### 缓冲

**缓冲（Buffer）**最常见于IO系统中。比如当希望向屏幕输出数据的时候，可能要多次调用`printf`函数，并且每次写入的数据只有几个字符，如果每次写数据都要进行一次系统调用，让内核向屏幕写数据，就明显过于低效了，因为系统调用的开销很大，它要进行上下文切换、内核参数检查、复制等，如果频繁进行系统调用，将会严重影响程序和系统的性能。

一个显而易见的可行方案是将对控制台连续的多次写入放在一个数组里，等到数组被填满之后再一次性完成系统调用写入，这是缓冲最基本的想法。

`fread -> fread_s -> _fread_nolock_s -> _read ->ReadFile`