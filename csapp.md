Chapter 2
-----------
## **2.1**
### **2.1.3 寻址和字节顺序**
最低有效字节在最前面--小端法(little endian)；
最高有效字节在最前面--大端法(big endian);
假设变量x的类型为int，位于地址0x100处，它的十六进制为0x01234567，地址范围0x100~0x103的字节顺序依赖机器的类型：
大端法：
|   |0x100 | 0x101 | 0x102 | 0x103 |   
:-: | :-: | :-: | :-: | :-:
··· | 01 | 23 | 45 | 67 | ···

小端法：
|  | 0x100 | 0x101 | 0x102 | 0x103 |   
:-: | :-: | :-: | :-: | :-:
···| 67 | 45 | 23 | 01 | ···

现在大多数机器都使用小端法：Intel，Android，iOS

## **2.2**
### **2.2.2 无符号数的编码**
假设有一个整数数据类型有$w$位。我们可以将位向量写成$\vec{x}$，表示整个向量，或者写成$[x_{w-1},x_{w-2},...,x_0]$,表示向量中的每一位。把$\vec{x}$看做一个二进制表示的数，就获得了$\vec{x}$的无符号表示。在这个编码中，每个位$x_i$都取值为0或1，后一种取值意味着数值$2^i$应为数字值的一部分。我们用一个函数$B2U_w$(Binary to Unsigned的缩写，长度为$w$)来表示：  

**原理**：无符号数编码的定义  
对向量$\vec{x}=[x_{w-1},x_{w-2},...,x_0]$:  
$$B2U_w(\vec{x})=\sum_{i=0}^{w-1}x_{i}2^{i}$$

### **2.2.3 补码编码**
大多数机器都使用补码编码  
对于许多应用，我们希望能表示负值。最常见的有符号数就是计算机表示方式就是
**原理**：补码编码的定义  
对向量$\vec{x}=[x_{w-1},x_{w-2},...,x_0]$:  
$$B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_{i}2^{i}$$
最高有效位$x_{w-1}$也称为符号位，它的权重为$-2^{w-1}$，是无符号数表示中权重的负数。符号位被设置成1时，表示值为负，而当设置为0时，值为非负。  

### **2.2.5 C语言中的有符号数与无符号数**
C语言中执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数。  

### **2.2.6 扩展一个数字的位表示**
将无符号数转换成一个更大的数据类型，只需在开头添加0。  
将补码数转换成一个更大的数据类型，只需在开头添加最高有效位(0或1)，即扩展最高有效位。  
当把short转换成unsigned时，先改变大小，再完成有符号到无符号的转换。  
### **2.2.7 截断数字**
当将一个$w$位的数截断为一个$k$位数字时，我们会丢弃高$w-k$位。截断一个数字可能会改变它的值。  

## **2.3**
### **2.3.1 无符号加法**
对在范围$0 \leq x,y \leq UMax_{w}$中的$x$和$y$，令$x=x+^{u}_{w}y$。则对计算$s$，当且仅当$s<x$(或等价的$s<y$)时，发生了溢出。  
模数加法形成了一种数学结构，称为**阿贝尔群(Abelian group)**，它是可交换和可结合的。它有一个单位元0，并且每个元素有一个加法逆元。考虑$w$位的无符号数的集合，执行加法运算$+_{w}^{u}$。对于每个值$x$，必然有某个值$-_{w}^{u}x$满足$-_{w}^{u}x+_{w}^{u}x=0$。  
**原理：**无符号数求反  
对满足$0 \leq x<2^{w}$的任意$x$，其$w$位的无符号逆元$-_{w}^{u}x$由下式给出：
$$$$
$$ -_{w}^{u}x=
\begin{cases}
    x, & x=0 \\
    2^{w}-x, & x>0
\end{cases}
$$


### **2.3.2 补码加法**
大多数机器使用相同的机器指令来执行无符号或者有符号加法。  
先将参数转换为无符号数，执行无符号加法，再将结果转换为补码。  
练习题2.30：判断补码加法  是否溢出
```C
boolean tadd_ok(int x,int y){
    int sum = x + y;
    bool neg_over = x < 0 && y < 0 && sum >= 0;
    bool pos_over = x >= 0 && y >= 0 && sum < 0;
    return !neg_over && !pos_over;
}
```

练习题2.31
> ```C
> /* Determine whether arguments can be added without overflow */
> /* WARNING: This code is buggy. */
> int tadd_ok(int x, int y) {
>     int sum = x+y;
>     return (sum-x == y) && (sum-y == x);
> }
> ```
这种方法是无法判断溢出的，因为x＋y无论是否溢出，x＋y－y始终等于x是因为补码加法可以形成一个阿贝尔群，由阿贝尔群的交换律和结合律有(x+y)-x==y。  

练习题2.32：判断减法是否溢出  
```c
/* Determine whether arguments can be subtracted without overflow */
/* WARNING: This code is buggy. */
int tsub_ok(int x, int y) {
    return tadd_ok(x, -y);
}
```
这样写是存在一定问题的，没有考虑TMin（即取值范围的最小值，32位时为-2147483648），TMin没有相反数，所以需要考虑$y$为TMin的情况。  

### **2.3.4 无符号数乘法**
对满足$0 \leq x,y \leq UMax_w$的$x$和$y$有：
$$x*_{w}^{u}y=(x \cdot y)\bmod 2^{x}$$

### **2.3.5 补码乘法**
有符号二进制乘法和无符号二进制乘法，他们获得的最终结果的二进制表示是一样的。  

### **2.3.7 除以2的幂**
对于无符号数来说，除以2的幂即算数右移  
对于补码来说，除以2的幂即算数右移，向下舍入，即大于0时向下舍入，小于0时向负无穷舍入。若想向上舍入，则需要加偏置，如算数移位$k$位时，加上的偏置应为`((1<<k)-1)`。  
以上结论表示，对于使用算数右移的补码机器，计算数值$x/2^{k}$的表达式为:  
`(x<0 ? x+(1<<k)-1 : x) >> k`  

## **2.4 浮点数**

### **2.4.1 二进制小数**
十进制表示法用如下形式表示：  
$d_{m}d_{m-1} \cdots d_{1}d_{0}.d_{-1}d_{-2} \cdots d_{-n}$  
其中每个十进制数$d_{i}$的取值范围是0~9，这个表达式描述的数值$d$定义如下：  
$$d=\sum_{i=-n}^{m} 10^{i}\times d_{i}$$
数字权的定义与十进制小数点符号('.')相关，小数点左边的数字权是10的正幂，得到整数值，右边是10的负幂，得到小数值。  
类似的，考虑一个形如$b_{m}b_{m-1} \cdots b_{1}b_{0}.b_{-1}b_{-2} \cdots b_{-n}$的表示法，其中每个二进制数字，或者称为位，$b_{i}$的取值范围是0和1，这种表示法表示的数字定义如下:
$$b=\sum_{i=-n}^{m} 10^{i}\times b_{i}$$
现在小数点符号('.')左边的数字权是2的正幂，右边是2的负幂。  

### **2.4.2 IEEE浮点表示**
IEEE浮点标准用$V=(-1)^{s}\times M\times 2^{E}$的形式来表示一个数:  
* 符号(sign) &ensp; $s$决定这数是负数还是整数，而对于数值0的符号位解释作为特殊情况处理。  
* 尾数(significand) &ensp; $M$是一个二进制小数，它的范围是$1 \sim 2-\epsilon$，或者是$0 \sim 1-\epsilon$。  
* 阶码(exponent) &ensp; $E$的作用是对浮点数加权，这个权重的范围是2的$E$次幂（可能是负数）。  

将浮点数的位表示划分为三个字段，分别对这些值进行编码：
* 一个单独的符号位$s$直接编码符号$s$。  
* $k$位的阶码字段`exp`$=e_{k-1} \cdots e_{1}e_{0}$编码阶码$E$。  
* $n$位小数字段`frac`$=f_{n-1} \cdots f_{1}f_{0}$编码尾数$M$，但是编码出来的值也依赖于阶码字段的值是否等于0。  



# **&sect; 3 程序的机器级表示**
## **3.2 程序编码**  
### **3.2.1 机器级代码**  
机器代码中一些通常的处理器  
* 程序计数器（通常称为“PC”，在x86-64中用`%rip`表示）
* 整数寄存器
* 条件码寄存器
* 向量寄存器  

### **3.2.2 代码示例**  
使用编译器+指令`-s`，得到编译后的汇编代码`.s`文件  
使用编译器+指令`-c`，得到编译并汇编代码`.o`文件  
使用编译器+指令`-0`，得到可执行文件  
使用反汇编器(disassembler)程序反汇编代码，带'`-d`'命令行标志的程序OBJDUMP(表示“object dump”)可以充当这个角色。  
> ```objdump -d <filename>```

前面都是编译器和汇编器的作用，还没有讲到链接器：  
链接器的任务之一就是为函数调用找到匹配函数的可执行代码的位置。  

## **3.4 程序编码**  
在常见的程序里不同的寄存器扮演不同的角色，其中最特别的是栈指针`%rsp`，用来指明运行时栈结束的位置。有些程序会明确的读写这个寄存器。  

## **3.4.2 数据传送指令**  
几个术语：  
字节：8位，后缀：b  
字：16位，后缀：w  
双字：32位，后缀：l  
四字：64位，后缀：q  
`mov`类指令也有`movb,movw,movl,movq`，分别对应这几种大小的操作数。  

![fig.3-2](./data/src/fig.3-2.png)  

x86-64有16个64位通用寄存器，如最左侧所示，可以对每个寄存器的低字节操作，比如要访问`%rax`的低8位，则可以访问`%al`。  
同理，也有`%ax`对应16位，%eax对应32位，`%rax`对应64位。  
有一条特殊规则：当对某个寄存器的低4字节操作时，如`%eax`，会自动把高4个字节全置为0。  

当我们调用汇编器时，下面代码的每行汇都会产生一个错误消息，讲出原因  

| 指令 | 分析 |
| :- | :- |
| `movb $0xF, (%ebx)` | x86-64内存地址为4 word，使用内存的寄存器必须是四个字， <br> 正确答案为`movb $0xF, (%rbx)`|
| `movl %rax, (%rsp)`| `movl`只传送两个字而`%rax`是四个字，改成 <br> `movq %rax, (%rsp)` 或者 `movl %eax, (%rsp)`|
| `movw (%rax), 4(%rsp)` | 两个操作数不能都是内存引用 |
| `movb %al, %sl` | 无`%sl`寄存器 |
| `movq %rax,$0x123` | 目的位置不能为立即数 |
| `movl %eax, %rdx` | 有副作用，在x86-64模式下会将 <br> `%rdx`的高位4个字节设置成0 |
| `movb %si, 8(%rbp)` | `movb`只传送一个字节而`%si`是一个字，大小不同，<br> 改成`movw %si, 8(%rbp)` |

**汇编指令注意事项:**  
* 在`mov`指令中，两个操作数只允许有一个内存引用，即不允许有`mov (%rax), (%rsp)`之类的情况发生
* 当使用间接寻址时（即使用了$(r_{a})$作为操作数，其操作数值为$M[R[r_{a}]]$），注意寄存器的字长要和内存的字长相匹配，如x86-64的内存字长为64位，此时使用的寄存器应为`%rax`，而不能为`%rbx`。
* 使用`b,w,l,q`这些后缀的时候，一般只用考虑寄存器的大小。
* 当执行强制类型转换既涉及大小变化又涉及C语言中符号的变化的时候，操作应先改变大小。
* ……

**练习3.4**  
将以下的程序转换成汇编语言  
假设`sp`和`dp`的值分别存储在寄存器`%rdi`和`%rsi`中对于表中的每个表象，给出指定数据传送的两条指令。其中第一条应该从内存中读书，做适当的转换并设置寄存器`%rax`的适当部分，然后，第二条指令要把`%rax`的适当部分写到内存，在这两种情况中，寄存器的部分可以是`%rax`、`%eax`、`%ax`或`%al`，两者可以互不相同。记住当执行强制类型转换既涉及大小变化又涉及C语言中符号的变化的时候，操作应先改变大小。  
```C
src_t *sp;
dest_t *dp;
*dp = (dest_t) *sp;
```
| src_t | src_t | 指令| 解析 |
| :- | :- | :- |  :- |
| long | long | `movq (%rdi), %rax` <br> `movq %rax, (%rsi)` | long为8字节，故两条都是`movq` |
| char | int | `movsbl (%rdi), %eax` <br> `movl %eax, (%rsi)` | 先将char扩展成int，故后缀为`bl`， <br> char为有符号，故为`sbl`，后面直接传递到`(%rsi)`。|
| char | int | `movsbl (%rdi), %eax` <br> `movl %eax, (%rsi)` | 同上，目标位置符号不同。|
| unsigned char | long | `movzbl (%rdi), %eax` <br> `movq %rax, (%rsi)` | uchar为无符号扩展，后缀为`zbl`，字节扩展只能到`l`， <br> 此时如果更新寄存器的低4字节，高4字节会自动置为0。|
| int | char | `movl (%rdi), %eax` <br> `movb %al, (%rsi)` | 第一条先直接读4个字节，第二条截断到1字节即可。|
| $\vdots$ | $\vdots$ | $\vdots$ | $\vdots$ |

**指针示例**  
参数`xp`是一个纸箱long类型的整数的指针，语句`long x = *xp`表示我们将读存储在`xp`所指位置中的值，并将它放到名字为`x`的局部变量中。这个读操作称为指针的间接引用(pointer dereferencing)，C操作符`* `执行指针的间接引用。C操作符` &`（称为“取址”操作符）创建一个指针，指向变量的位置。


### 4.2.2 组合电路和HCL布尔表达式

C的逻辑表达式有个属性就是它们可能只被部分求职，如果一个AND或OR操作的结果只用对第一个参数求值就能确定，那么久不会对第二个参数求职了。例如下面的C表达式：  
`(a && !a) && func(b, c)`  
这里`func`是不会被调用的，因为表达式`(a && !a)`求值为0。而组合逻辑没有部分求值这条规则，逻辑门只是简单的响应输入的变化。  

### 4.2.4 集合关系

判断集合关系的通用合适是：  
$iexpr$ in $\{iexpr_{1},iexpr_{2},\cdots,iexpr_{k}\}$  
这里被测试的值$iexpr$和待匹配的值$iexpr_{1} \sim iexpr_{k}$都是整数表达式。

## 4.3 Y86-64的顺序实现

### 4.3.1 将处理组织成阶段

通常，处理一条指令包含很多操作。将他们组织成某个特殊的阶段序列，即使指令的动作差异很大，但所有的指令都遵循统一的序列。每一步的具体处理取决于正在执行的指令。下面是关于各个阶段以及各阶段内执行操作的简略描述：
- **取指（fetch）**： 取指阶段从内存读取指令字节，地址为程序计数器（PC）的值。
- **译码（decode）**： 译码阶段从寄存器文件读取最多两个操作数，得到值`valA`和`/`或`valB`，通常，它读入指令`rA`和`rB`字段指明的寄存器，不顾有些指令是读寄存器`%rsp`的。
- **执行（execute）**：
- **访存（memory）**：
- **写回（write back）**：
- **更新PC（PC update）**：

处理器无限循环，执行这些阶段。

### 4.3.3 SEQ的时序

SEQ的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序计数器和条件码寄存器），随机访问存储器（寄存器文件、指令内存和数据内存）。组合逻辑不需要任何时序或控制———只要输入变化了，值就通过逻辑门网络传播。

用始终来控制状态单元的更新，以及值通过组合逻辑来传播。  
组合逻辑在一个周期当中就会被更新，但是程序计数器、寄存器文件和条件码寄存器在下一个时钟上升时才会被更新。

## 4.4 流水线的通用原理

在SEQ中，每个单元只在整个时钟周期的一部分时间内才被使用，所以会通过引入流水线来获得更好的性能。  
如在一个典型的自助餐厅流水线上，会允许多个顾客同时经过系统，而不是要等到一个用户完成了所有从头至尾的过程才让下一个开始。顾客按相同的顺序经过各个阶段，即使他们不需要某些菜。  
流水线化的一个重要特征就是提高了系统的 **吞吐量（throughput）** ，也就是单位时间内服务的顾客总数，不过它也会轻微的增加 **延迟（latency）** ，也就是服务一个顾客所需要的时间。  


# 5 优化程序性能

## 5.1 优化编译器的能力和局限性

**一个主要的妨碍优化的因素**--两个指针可能指向同一个内存位置的情况称为内存别名使用（memory aliasing）。在只执行安全的优化中，编译器必须假设不同的指针可能会指向内存中的同一个位置。  
如果编译器不能确定两个指针是否指向同一个位置，就必须假设什么情况都有可能，这就限制了可能的优化策略。  

**第二个妨碍优化的因素**--函数调用。如果函数有副作用--修改了全局程序状态的一部分。改变调用它的次数会改变程序的行为。  
大多数编译器不会试图判断一个函数是否没有副作用，如果没有，就可能被优化。相反，编译器会假设最糟的情况，并保持所有的函数调用不变。  
