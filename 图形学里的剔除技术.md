[图形学里的剔除技术 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/701883987)

包括 **CPU端的粗粒度剔除** 和 **GPU端的细粒度剔除**

剔除粒度可以分为对object/instance剔除、对cluster/chunk剔除和对triangle剔除。

- 对object/instance的剔除通常在CPU进行，目的是减少物体的Draw Call
- 对cluster/chunk的剔除通常用 Compute Shader 在GPU进行，目的是为了减少光栅化三角形的数量
- 对triangle的剔除通常通过硬件或者Compute Shader在GPU进行，目的是为了减少光栅化次数以及shading次数



## 视锥剔除

Frustum culling

1. 组织数据结构，通常为 BVH
2. 对于 BVH 测试：在外面则剔除；在内部不剔除；相交则进一步测试

## 遮挡剔除

Occlusion culling

通过 Early-Z 可以解决可见性问题，但是会有 OverDraw 和 DrawCall 过多的问题。

遮挡剔除算法分为两大类：

- point-based：每帧执行，从观察点形成视锥体即遮挡剔除的有效范围
- cell-based：用更大的视锥体去包裹更多物体，划分空间为 cell，直接取 cell 中的结果，不需要每帧执行，可以预计算



1. **硬件遮挡查询（Occlusion Query）**：向GPU插入查询指令，查询指定的Draw Call中通过 Depth Test的数量。

   - 优化：包围盒、合批、粗深度缓冲区、支持断言/条件的遮挡查询

2. **层级深度缓冲剔除（Hierarchical Z Buffer）**：二分思想去做剔除，用一张粗糙的深度图做测试，没通过则说明该物体需要剔除掉了，通过深度测试则使用更低一级更精细的深度图继续做深度测试。

   - 构建 z-buffer 金字塔：先生成一张全分辨率的z-buffer，每高一级（更粗糙）的z-buffer的 mipmap 内存的是更精细 mipmap 内的**最大深度值**（近处深度为0，远处深度为1），有这种生成规则是因为剔除的判断条件是包围盒的最近深度>对应深度图区域的最远深度。

   1. 使用一些遮挡物来获得深度图并生成完整的z-buffer金字塔
   2. 遍历物体八叉树把物体包围盒投影到屏幕空间中，根据包围盒大小估计需要用到的z-buffer金字塔的mip层级
   3. 针对mip层级进行深度测试，如果遮挡结果不明确则用更精细的mip继续测试

   - 八叉树和BVH都是对GPU不友好且昂贵，所以大多数场景都不会用上面完整版本的Hi-Z算法，会使用改进版的 Hi-Z。

3. **软件光栅化剔除**：软件光栅化即为纯 CPU 的剔除，该方法不经过GPU所以不会有 GPU stall 的问题。在 CPU 侧对场景进行一遍光栅化，输出一个 depth buffer，之后使用它来进行剔除。

4. **基于 Masked 的软光栅**：Masked Software Occlusion Culling, MSOC。在光栅化过程中直接计算出全分辨率的三角形遮挡关系且用降分辨率的贴图去存储，计算过程中也会用生成的深度图去指导光栅化的进行，同时利用现代CPU的向量指令集如AVX，SSE 4.1 和SSE 2 优化执行效率。最大的优势在于他可以在更新深度的同时直接做遮挡剔除，而不需要输出完深度再用深度指导剔除。

   1. 光栅化：计算顶点的数值确定三角形覆盖的Tile。通过 scanline 对三角形进行扫描并光栅化。每个SIMD单元负责32×1或者8×4个像素的处理逻辑。
   2. 计算 Hierarchical Depth Buffer 和遮挡剔除：每个Tile只存3个数据，两个浮点数Z0max，Z1max和32位的mask（uint）

5. GDC2023 移动平台高性能软光栅



## 入口剔除

入口剔除是视锥剔除的一种拓展方案，因为室内环境下视锥剔除效率其实是非常低的，室内环境大部分物体都处于视锥体之内，但是当室内划分了多个空间的时候，大部分墙壁后的物体都是看不到需要被剔除的，标准的视锥剔除方案做不到这一点，往往需要搭配遮挡剔除使用。

一般实现都是通过预处理标记每个房间相关联的空间数据，在对应空间内视锥体会根据“门”的大小而缩小再做一遍视锥剔除。



## GPU Driven 剔除

GPU Driven 剔除不是一种具体的算法，而是一种思路，其核心思路是减少CPU和GPU的通信，尽量将所有的渲染相关的事物都放在GPU做，同时利用GPU的并行高算力的特性去做更细粒度的剔除。

前面的大部分剔除方案都有一个问题，剔除结果需要回读到CPU。这是因为剔除的终极目的就是没有多余的 DrawCall 和 OverDraw，但是要减少 DrawCall 还是得回到 CPU，因为普遍的渲染管线里都是由 CPU 发送 DrawCall，所以一般流程都是 GPU 回读深度图，在 CPU做剔除计算，最后发送没有被剔除的物体 DrawCall 进行渲染。

GPU Driven Pipelines 号称一个Draw Call解决战斗，其实就是一个DrawCall把当前可视场景所有的渲染资源（包括几何信息，材质信息，变换信息，包围盒信息）打包成Buffer上传到GPU的显存里（这里不包括静态合批早已经送到显存的数据），这个时候显存里面已经有数据了，就可以直接利用之前算好的z-buffer（在显存里，不需要回读）在Compute Shader做剔除，做完后通过 execute indirect 指令向GPU发送绘制指令。

CPU 端：

- **粗糙视锥剔除**：这一步通常会做视锥体剔除和用软光栅在CPU做粗糙的遮挡剔除，减少CPU传到GPU的数据量，减少带宽压力。
- **合并Instance**：GPU Driven技术用了Merge-Instanceing技术把不同mesh的instance合成成一个大的Instance，这样就可以一个DrawCall提交所有场景数据了

GPU 端：

- **Instance剔除**：用视锥剔除和遮挡剔除进行更细粒度的剔除
- **拆分成Chunk**
- **Cluster剔除**：把mesh切分成cluster目的是进行更加细粒度的剔除，虽然对cluster会耗费一定性能，但是可以大大减少shading次数
- **三角形剔除**
- **合并index**



## Z-Cull

Z-Cull相当于硬件版本的Hi-Z，该方法和Early Z非常类似，但是他们的粒度不一样，Z-Cull通常是以Pixel Tile（8×8或者16×16个像素）为粒度进行深度测试的，具体思路和 TBR 类似，以一个非常粗的粒度去光栅化，用一个粗糙Pixel去对应最细粒度的十几个Pixel，如果这个粗粒度的Pixel都通不过深度或者模板测试，则不需要后续细化的光栅化了，这样可以大幅度提高深度和模板测试的效率。

Z-Cull和Early-Z还有一个区别就是Z-Cull是不需要向depth buffer写入深度的。

总结来说Z-Cull实际上是对Early-Z的一种二分层级加速优化。

Z-Cull通常只在 TBR 架构上的硬件可以启用。



## Early Z & Pre-Z

Early-Z 和 Pre-Z 的本质区别就是 Early-Z 不需要额外的 Draw Call，而 Pre-Z 则是要多一倍的 Draw Call 去拿到深度。

**Early-Z**：

- 把深度测试提前到Pixel Shading之前，没通过提前深度测试的Pixel就不执行后续的 shading 了

- 由于硬件光栅化要计算梯度，所以Pixel是以Quad（2×2）的形式去做Early-Z的，且Quad的深度缓存内数据是Z字形排列的。

- 局限性：开启alpha test、在 Pixel Shader 写入深度或者 discard pixel 等操作都会使 Early-Z 失效，因为 Early-Z 用来做深度测试判断的深度是光栅化插值处理的原始深度，alpha test 等操作都有可能导致原始深度在片元阶段与 late-z 阶段之间被修改，这就会导致提前深度测试结果不正确。

**Pre-Z**：

- 提前进行一次代价很小的渲染，这次渲染不做shading只写入深度，有了Pre-Z的深度图就可以用这个深度图去做提前深度测试了，这样虽然会导致DrawCall数量翻倍但是配合Early-Z使用能确保下一个Pass的shading数量和屏幕空间的Pixel数量是一致的，并不会带来多余的shading浪费。
- 局限性：在移动端，功耗的瓶颈在于Draw Call数量，这个时候需要综合考虑是否需要使用Pre-Z以及对Pre-Z做一些额外出来等操作来评估是否值得用 double draw call 去减少shading次数。

## 裁剪剔除

裁剪剔除在几何处理阶段屏幕映射前进行，粒度是三角形，也叫视锥体剔除。

只有完全位于可视空间额内部的图元才需要被发送给光栅化阶段，因此在几何阶段对粗粒度的物体做基于三角形图元的剔除可以有效的减少无效shading的次数。



## 背面剔除

背面剔除发生在屏幕映射之后光栅化阶段之前，其剔除粒度是三角形，目的是剔除掉背对摄像机的三角形，被剔除掉的三角形不再参与后续的三角形设置等流程。

- screen space剔除：判断屏幕空间里三角形三个顶点环绕顺序是否同为顺时针或逆时针来确定是否背对屏幕，这个测试可以通过叉乘判断正负的方法来实现。
- view space剔除：判断观察空间中视点和三角形的法线夹角是否为锐角来确定是否背对观察者，主要通过还原观察空间坐标点乘来实现。
- 局限性：标准的背面剔除并不是一定能带来优化的，因为背面剔除算法本身就需要一定的计算量。



**集群背面剔除**：可以先通过生成一个三角形几何，只做一次判断来决定是否要剔除掉整个三角形集合。

**预烘焙的聚类立方体剔除**：用预处理的方式先计算一个最小立方体，每个立方体面有n×n个像素，每个像素存储64位数据分别对应这64个三角形是否背对视角。

**小三角形剔除**：通常用于剔除落在两个像素中心相邻样本之间的微小三角形的



## 预计算遮挡剔除

PVS



## 细节剔除

细节剔除是一种为了渲染速度而牺牲质量的技术，当观察者在运动的状态时，人眼是很难留意到场景中十分微小的细节的，所以在人物移动的时候会开启细节剔除把微小的物体直接剔除掉，在静止的时候再禁用细节剔除。